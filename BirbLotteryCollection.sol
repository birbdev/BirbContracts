/*
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNXK0OkkxxddooooooooooddxxkkO0KXNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMWNK0kxdolllllloooddddddddddooollllllodxk0KNWMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMWNKOxdllllodxkOO0KXXNNNNWWWWNNNNXXK0OOkxdolllldxOKNWMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMWX0xolllodxO0XNWMMMMMMMMMMMMMMMMMMMMMMMMMMWNX0OxdollloxOXWMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMWX0xollldxOKNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOxdllloxOXWMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMNKkollldk0NWMMMMMMMMWXK0OkxdoooooooooodxxO0KXWWMMMMMMMMMWN0kdlllokKNMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMN0xollok0NWMMMMMWN0kol:,'.....................,;coxOXWMMMMMMMWN0xollox0NMMMMMMMMMMMMMM
 * MMMMMMMMMMMMN0dllldOXWMMMMMW0xc,.....';;:clloooddddddooolcc:;,'...':oONMMMMMMMWXOdllld0NMMMMMMMMMMMM
 * MMMMMMMMMMWKxllldONWMMMMWKx:....,;clodxxxxxdddddddddddddddxxxxdol:,...,lONMMMMMMWNOdlllxKWMMMMMMMMMM
 * MMMMMMMMWXkolloOXWMMMMW0o'...,codxxxxdddoooooooooooooooooooooodddxxoc;...:xXMMMMMMWNOollokXWMMMMMMMM
 * MMMMMMMW0dlloxXWMMMMMXo'..':oxxxxdddooooooooooooooooooooooooooooooodddoc'..;kNMMMMMMWXxolld0WMMMMMMM
 * MMMMMMNOolld0WMMMMMWO;..'cdxxxxdoooooooooooooooooooooooooooooooooooooooddc'..lKMMMMMMMN0dlloONMMMMMM
 * MMMMMNklllxKWMMMMMNd'..;oxxxddooooooooooooooooooodddxkkOO000000OOOkkxdooodl;..;0WMMMMMMWKxlllkNMMMMM
 * MMMMXxlllxXMMMMMMNo...cxxxxdoooooooooolc::::coxO0KXXNNNNNNNNNNNNNNNNXK0Okxoo:..;0WMMMMMMMXxlllxXMMMM
 * MMMNxlllkNMMMMMMWx..'lxxxxdoooocclll:;'......'ckXNNNNNNNNNNNNNNNNNNNNNNNNX0Od:..:KMMMMMMMMNklllxNMMM
 * MMNklllxNMMMMMMMO,..lxxxdoooooo:,,'...:c'.......lKNNNNNNNNNNNNNNNNNNNNXNNNNNXk:..lNMMMMMMMMNxlllkNMM
 * MW0olldXMMMMMMMXc..:xxxdooooooooll;..cXNo........oKXNNNNNNNNNNX0xolc::::cldkKNO;.'kMMMMMMMMMXdlloOWM
 * MXdllo0WMMMMMMMx..,dxxxooooooooooo;...;:'......'.:kKNNNNNNNX0o;'.,;::c::;'..'cxl..lNMMMMMMMMW0olldKM
 * WklllkNMMMMMMMXc..cxxxdooooooooooo:...........;;.lKXNNNNNN0l'.,ok0KKKKXXK0ko:.....,OMMMMMMMMMNklllkW
 * KdlloKMMMMMMMMO'.,oxxdooooooooooool:.......';:;'c0NNNNNNNO;..;k0000000000KXXKkc....lNMMMMMMMMMKdlldK
 * OlllkNMMMMMMMWd..;xxxdooooooooooood0Oc,''',;;;:xXNNNNNNNO,.'cxO0O000000OOO00KX0o'..'OMMMMMMMMMNklloO
 * xllo0WMMMMMMMXc..cxxdoooooooooooookXNNKkxdddk0XNNNNNNNNKc.:kOO0000OOOO0OOO0O00KKl...oWMMMMMMMMW0lllx
 * dlloKMMMMMMMM0,..collllooooooooood0NNNNNNNNNNNNNNNNNNNNx..lOOOOO0OOOOOOOOOOO0O0KO;..:XMMMMMMMMMKolld
 * olldXMMMMMMMWd....'''''',:cloooooxKNNNNNNNNNNNNNNNNNNNXl..;xOOOOOOOkkkkkkkOOOOO0Oc..;KMMMMMMMMMXdllo
 * olldXMMMMMMKl'.',;;;;;;,'..';coookXNNNNNNNNNNNNNNNNNNNK:..',cllllllllccclllodxkOOl..;0MMMMMMMMMXdllo
 * olldXMMMMMK:..,;;;;;;;;;::;,..,:o0NNNNNNNNNNNNNNNNNNNNK:.co;..............';;;;:oc..'o0NMMMMMMMXdllo
 * dlldKMMMMXl..,,;;;;;;;;;,,;::;,.'o0NNNNNNNNNNNNNNNNNNNK:.:kko;....'',,,'..:0Oxd;.....'':0WMMMMMKdlld
 * xllo0WMWKc..',,;;;;;;;;;;,'',;::,.,oKNNNNNNNNNNNNNNNNNXl.;dxkkdc,.........';,,k0;...'c;.:XMMMMM0ollx
 * klllxOkl,..',,;;;;;;;;;;;;;'..';::,.,dXNNNNNNNNNNNNNNNNk''lxdxkkkdocc:::ccl:..dXl...,c:.,0MMMMNklllk
 * 0c,'.....',,;;;;;;;;;;;;;;;;;'..';c:'.:ONNNNNNNNNNNNNNNKc.;dxddxxxkkkkkkkxxc.'ONl..';c:.,0MMMMXdllo0
 * K:....''''',;;;;;;;;;;;;;;;;;;,'..,:c;.,xXNNNNNNNNNNNNNNO;.;oddxdddxddddddl'.dNXc..,::,..cXMMWOlllxX
 * Wx'.''''''''''',,;;;;;;;;;;;;,,'...';c:..;loxOKXNNNNNNNNNO:.'cdxxddddxxdo:.'dXNk'.,;:,.,,.:OWKdllo0W
 * MXo,,;;;;;;;;;,,,,'',;;;;;,'.,cooc;.';c:.....',:lxkOXNNNNNKd,.';:cllcc:,'':dxoc'.,;:;'';::.'dxlllkNM
 * MW0:'',,,,,;;;;::::;,''',,'.;kKXXX0x;';l;..,;;,,'''';cdOXNNNKxl:,,'',,,'',,''...';,,;;;,;c:.'clldXMM
 * MMWk;..''....'',,;;:::;,'...lO0KKKKXO:'cc'..,;;;;;;;,''';lkKNNNXXKOxl;''',,;;'.';,:dOKk;.::.'clo0WMM
 * MMMWOcodc,;c;.''...',;;::;,.;dO00KKKKl.:l,...,,'...',;;;,'',lkKXOo;'.',,,'','..,,;kKKKO;'c,.'co0WMMM
 * MMMMW0d::lllloxdl:,...',,;:;',ldkOOOx;'cl,.':;'..':::,'',;;,'.,;'.,,,'','.....','l00KOc,:;...c0WMMMM
 * MMMMMWOodo:::::ccc:;'....',;;,',;::;,,cl:'.c00kd:;cd0Oxl;'.,;;,,,,'':oxxc;oo'.,,'cxxo:,,,.,,,kWMMMMM
 * MMMMMMMNklc:;lddl:'';cll;...',,,,,,;:cc:,..:ocldo:.:xO0K0kl,.';,',lk00klcddl'..,,,;,,,'...:d0WMMMMMM
 * MMMMMMMMXd;;dkxdo:;ccclodl:,'....''''''..;oxd::dxollclxO0KK0o,.,o0KKOdlcoo::l;...'''...,oodXMMMMMMMM
 * MMMMMMMMMWKxlc:;:ldxdc:;;,,,'.,::;;;;;';dOKKKk:lO0KKOxoldxdddl;cdxxoodk00ooOKkc',,..,c:;xNWMMMMMMMMM
 * MMMMMMMMMMMNko;,:c;,''''......';ldkOO0x::lodxxo:cxOO0OdccoxkOOOkxxoclk0kllxkdo;';,...':xNMMMMMMMMMMM
 * MMMMMMMMMMMMMN0xl;....''',,,,,'...,:ldko,cdxdddl;:cclldO0kdoddxddddxxlc;:oddo:...',;ckXMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMNk:'',;;;;;::;;,...':llll;,ck0KKKOc,;d0OdloodxkOkkkdllxo:xKKOo'.,;;lONMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMN0dc;;;:clc,','..'cdkOOkdl:lkOOoldk0xllxxxkOOOOkxxOdcxolkdc,.'ok0NMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMWXOdollc'.';;,'...';coddc,;l::x00dcdOxkOdcd00OxokKold;,;c:lONWMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMWNKkc'.,;;;;,,'..,c;,cxkl,lkko:d0xkKOocdkkOklxXdcdclxOXWMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMNKkdoc:;;;,'..,cc:col;oxxccOkx0KKKKOdolooOXOkKXNMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOkdol:'..';,'',oxd:cxxO0KXKK0O0OO0NWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOxoc;,:c:okxc:kK00XNNNNNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * 
 * Birb Lottery Collection
 * 
 * Created, deployed, run, managed and maintained by CodeCraftrs
 * https://codecraftrs.com
 *
 * Written by: MrGreenCrypto
 *
 * SPDX-License-Identifier: None
 */

pragma solidity 0.8.17;

interface IBEP20 {
    function decimals() external view returns (uint8);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);
}

interface ICCVRF {
    function requestRandomness(uint256 requestID, uint256 howManyNumbers) external payable;
}

interface IDEXRouter {
    function WETH() external pure returns (address);
    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;
}

contract BirbLotteryCollection {
    address public constant CEO = 0x7D70D9EDFa339895914A87E590921c0EECb3c2CC;
    address public constant CC = 0x7c4ad2B72bA1bDB68387E0AE3496F49561b45625;
    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;

    IDEXRouter private router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    IBEP20 public BIRB = IBEP20(0x88888888Fc33e4ECba8958c0c2AD361089E19885); // will be updated to use Birb 2.0 address
    ICCVRF public randomnessSupplier = ICCVRF(0xC0de0aB6E25cc34FB26dE4617313ca559f78C0dE);
    
    uint256 private vrfCost = 0.002 ether;
    uint256 public priceOfTicketBurnLottery = 500;
    uint256 public maxTicketsPerWallet = 10;
    uint256 public maxTicketsPerDraw = 50;
    uint256 public chanceToWinSuperJackpot = 1000;
    uint256 public ticketPrice = 500;
    uint256 public minBuy = 0.02 ether;
    uint256 public maxBuy = 1 ether;
    
    bool public burnJackpotIsOpen = true;
    bool public maintenanceMode;
    
    address[] public players;
    address[] public stillGetMoney;
    uint256[] public howMuch;
    mapping (uint256 => uint256) public whichLottery;
    mapping (uint256 => uint256) public birbAtNonce;
    mapping (uint256 => address) public playerAtNonce;
    mapping (uint256 => bool) public nonceProcessed;

    uint256 private nonce;
    uint256 private decimals;
    uint256 public burnJackpot;
    uint256 public superJackpot;
    uint256 public birbToBurn;
    uint256 public totalTicketsSoldInThisLottery;
    
    event Winner(address winner, uint256 tokensWon, uint256 lotteryID);
    event WinnerToBePaid(address winner, uint256 tokensWon, uint256 _nonce, uint256 lotteryID);

    modifier onlyOwner() {if(msg.sender != CEO && msg.sender != CC) return; _;}
    modifier onlyVRF() {if(msg.sender != address(randomnessSupplier)) return; _;}

    constructor() {
        decimals = BIRB.decimals();
    }

    receive() external payable {}

    function BetBirb() external payable {
        require(!maintenanceMode, "Lottery is currently suspended");
        require(msg.value >= vrfCost, "Randomness has a price!");
        IBEP20(BIRB).transferFrom(msg.sender, address(this), ticketPrice * (10**BIRB.decimals()));
        whichLottery[nonce] = 2;
        playerAtNonce[nonce] = msg.sender;
        randomnessSupplier.requestRandomness{value: vrfCost}(nonce, 1);
        nonce++;
    }

    function BuyBurn(uint256 tickets) external payable {
        require(!maintenanceMode, "Lottery is currently suspended");
        require(burnJackpotIsOpen, "Jackpot is full, please wait");
        require(msg.value >= vrfCost*6/5, "Randomness has a price");
        require(tickets + getTicketsBought(msg.sender) <= maxTicketsPerWallet, "Trying to buy too many tickets");
        
        if(totalTicketsSoldInThisLottery + tickets > maxTicketsPerDraw) tickets = maxTicketsPerDraw - totalTicketsSoldInThisLottery;
        totalTicketsSoldInThisLottery += tickets;

        uint256 tokensToSend = tickets * priceOfTicketBurnLottery * (10**decimals);

        BIRB.transferFrom(msg.sender, address(this), tokensToSend);
        burnJackpot += tokensToSend / 2;
        superJackpot += tokensToSend / 10;
        birbToBurn += tokensToSend * 4 / 10;
        for(uint256 i= 1; i<=tickets; i++) players.push(msg.sender);

        // getBonusTickets
        whichLottery[nonce] = 11;
        playerAtNonce[nonce] = msg.sender;
        randomnessSupplier.requestRandomness{value: vrfCost}(nonce, tickets);
        nonce++;

        // if the jackpot is full, draw a winner
        if(players.length >= maxTicketsPerDraw) drawBurnWinner();
    }

    function betBnbToWinBirb() external payable {
        require(!maintenanceMode, "Lottery is currently suspended");
        require(msg.value >= minBuy, "Minimum bet not reached");
        require(msg.value <= maxBuy, "Maximum bet exceeded");

        uint256 balanceNow = BIRB.balanceOf(address(this));
        buyBirbWithBnb(msg.value - 0.002 ether);
        uint256 birbBought = BIRB.balanceOf(address(this)) - balanceNow;

        whichLottery[nonce] = 3;
        playerAtNonce[nonce] = msg.sender;
        birbAtNonce[nonce] = birbBought;
        randomnessSupplier.requestRandomness{value: vrfCost}(nonce, 1);
        nonce++;
    }

    function supplyRandomness(uint256 _nonce,uint256[] memory randomNumbers) external onlyVRF {
        uint256 lotteryId = whichLottery[_nonce];
        if(lotteryId == 1) {
            if(nonceProcessed[_nonce]) return;
            address winnerAdd = players[(randomNumbers[0] % players.length)];
            BIRB.transfer(winnerAdd, burnJackpot);
            BIRB.transfer(DEAD, birbToBurn);
            nonceProcessed[_nonce] = true;
            emit Winner(winnerAdd, burnJackpot, 1);
            birbToBurn = 0;
            burnJackpot = 0;
            burnJackpotIsOpen = true;
            delete players;
            totalTicketsSoldInThisLottery = 0; 
        }

        if(lotteryId == 11){
            if(nonceProcessed[_nonce]) return;
            nonceProcessed[_nonce] = true;
            for(uint256 i= 0; i < randomNumbers.length; i++) {
               if(randomNumbers[i] % chanceToWinSuperJackpot == 0) {
                    address winner = playerAtNonce[_nonce];
                    IBEP20(BIRB).transfer(winner,superJackpot);
                    emit Winner(winner, superJackpot, 11);
                    superJackpot = 0;
                    return;
                } 
            }
        }

        if(lotteryId == 2) {
            if(nonceProcessed[_nonce]) return;
            uint256 rand = randomNumbers[0] % 10000;
            address winner = playerAtNonce[_nonce];
            uint256 prizeMoney;

            if(rand == 0) prizeMoney = ticketPrice * 200 * 10**decimals;
            else if(rand <= 10)  prizeMoney = ticketPrice * 100 * 10**decimals;
            else if(rand <= 210)  prizeMoney = ticketPrice * 10 * 10**decimals;
            else if(rand <= 1110)  prizeMoney = ticketPrice * 5 * 10**decimals;
            else if(rand <= 2110)  prizeMoney = ticketPrice * 2 * 10**decimals;

            if(prizeMoney > 0) {
                if(prizeMoney>BIRB.balanceOf(address(this)) - (burnJackpot + birbToBurn + superJackpot)) {
                    stillGetMoney.push(winner);
                    howMuch.push(prizeMoney);
                    emit WinnerToBePaid(winner, prizeMoney, _nonce, 2);
                    maintenanceMode = true;
                    nonceProcessed[_nonce] = true;
                    return;
                }
                BIRB.transfer(winner,prizeMoney);
                nonceProcessed[_nonce] = true;
                emit Winner(winner, prizeMoney, 2);
            }
            return;
        }

        if(lotteryId == 3) {
            if(nonceProcessed[_nonce]) return;
            uint256 rand = randomNumbers[0] % 10000;
            uint256 birbBoughtAtNonce = birbAtNonce[_nonce];
            address winner = playerAtNonce[_nonce];
            uint256 prizeMoney;

            if(rand == 0)  prizeMoney = birbBoughtAtNonce * 10;
            else if(rand <= 10)  prizeMoney = birbBoughtAtNonce * 5;
            else if(rand <= 1510)  prizeMoney = birbBoughtAtNonce * 2;
            else if(rand <= 6510)  prizeMoney = birbBoughtAtNonce;
            else prizeMoney = birbBoughtAtNonce / 2;

            if(prizeMoney > 0) {
                if(prizeMoney>BIRB.balanceOf(address(this)) - (burnJackpot + birbToBurn + superJackpot)) {
                    stillGetMoney.push(winner);
                    howMuch.push(prizeMoney);
                    emit WinnerToBePaid(winner, prizeMoney, _nonce, 3);
                    maintenanceMode = true;
                    nonceProcessed[_nonce] = true;
                    return;
                }
                BIRB.transfer(winner,prizeMoney);
                nonceProcessed[_nonce] = true;
                emit Winner(winner, prizeMoney, 3);
            }
            return;
        }
    }

    function getTicketsBought(address player) public view returns (uint256) {
        uint256 ticketsOfPlayer;
        for(uint256 i= 0; i < players.length; i++) if(players[i] == player) ticketsOfPlayer++;
        return ticketsOfPlayer;
    }
    
    function  buyBirbWithBnb(uint256 bnbToSpend) internal {
        address[] memory pathFromBNBToBIRB = new address[](2);
        pathFromBNBToBIRB[0] = router.WETH();
        pathFromBNBToBIRB[1] = address(BIRB);

        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnbToSpend}(
            0,
            pathFromBNBToBIRB,
            address(this),
            block.timestamp
        );
    }

    function drawBurnWinner() internal {
        whichLottery[nonce] = 1;
        randomnessSupplier.requestRandomness{value: vrfCost}(nonce, 1);
        nonce++;
        burnJackpotIsOpen = false;
    }

    function rescueAnyToken(address token) external onlyOwner {
        IBEP20(token).transfer(msg.sender, IBEP20(token).balanceOf(address(this)));
    }
    
    function rescueBNB() external onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }

    function activateMaintenanceMode() external onlyOwner{
        maintenanceMode = true;
    }

    function deactivateMaintenanceMode() external onlyOwner{
        if(stillGetMoney.length != 0){
            for(uint256 i= 0; i<stillGetMoney.length; i++) {
                BIRB.transfer(stillGetMoney[i], howMuch[i]);
                emit Winner(stillGetMoney[i], howMuch[i], 99);
            }
        }
        maintenanceMode = false;
    }
}
