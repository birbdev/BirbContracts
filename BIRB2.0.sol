/*
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXKkdlc;,...            ...,;cldOKNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMWX0xl;..                              ..;lx0NWMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMNOd:.                                         .':d0NMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMWXkc'                                                 .'lkXWMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMNOc.                                                        'lONMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMWKd,                                                              ,dXWMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMW0l.                           ...........                            .oKWMMMMMMMMMMMMM
 * MMMMMMMMMMMWKl.                     .';:codxxkkOOOOOkkkxdolc;,..                     .lKMMMMMMMMMMMM
 * MMMMMMMMMMXo.                  .':ldO00000OOkkkkkkkkkkkkkOOO00Oxoc,.                   .dNMMMMMMMMMM
 * MMMMMMMMWO,                 .;lxO000OkkxxddddddddooooooddodddxxkkOOko;.                  ;OWMMMMMMMM
 * MMMMMMMXo.                .ck0K00OkxddoodddoooddddddddodoodddooddddxkOxl.                 .oNMMMMMMM
 * MMMMMMK:                .lO0K0Okddddodooddddodddddoddooddddddddddoooodxkxc.                 :KMMMMMM
 * MMMMWO,               .:k000OxdddddodoooddddddoddxxxkOO0000000000OOkkxdddxo,                 ;0MMMMM
 * MMMWO'               .o0K00kdddddoddool:;;;;:ok0KXXXNNNNNNNNNNNNNNNNXXK0Oxxd;.                ,0MMMM
 * MMM0'               .d0K0Oxdodo::llc;..      .;xKNNNNNNNNNNNNNNNNNNNNNNNNXKOx:                 ,0MMM
 * MMK;               .o000Odddooo:'..  .;;.       :0NNNNNNNNNNNNNNNXXXKKKXXNNNXk;                 :XMM
 * MNl                c0K0Ododooooool'  ;KK:        c0XNNNNNNNNNKkoc;,'...',:cdOKk'                 lNM
 * Wx.               ,kK0Oxoododooodl'   ..         ,x0NNNNNNXOc'  ..,;:::;,.. .'c,                 .kM
 * X;               .l000xddooddodddo;           ...c0XNNNNN0l.  .lk0KKKKKXK0ko;.                    :X
 * x.               'xK0Ododddooddoodo;.     ..',..:0NNNNNN0;   'd000000000KKKXKkc.                  .k
 * c                :OK0xdodddooododdx0k:......'':xKNNNNNNK:  .;dO0000000000000KXKd.                  l
 * '               .l00OdddddoododdodOXNXKkdoodk0XNNNNNNNXo. 'dO00000000000000000KKo.                 ,
 * .               .xK0kdddddoodddoox0NNNNNNNNNNNNNNNNNNNK;  ,k00000000000000000000O:                 .
 *                 ;OK0xddddddooddodkXNNNNNNNNNNNNNNNNNNNk.  .lkOOOOOOOkkkkkkkOOOO00o.                .
 *                 c0KOxdddoddodddodOXNNNNNNNNNNNNNNNNNNNx.   .,:ccc::::::::::cloxkOd.                .
 *                .dK0Ododdoodooddox0NNNNNNNNNNNNNNNNNNNNx. .:;'..................'::.                .
 * .              :OK0kdddddddddddoxKNNNNNNNNNNNNNNNNNNNNO' .lxdooooooodddddoddl'                     .
 * .             .d00OxddoddoodddodOXNNNNNNNNNNNNNNNNNNNNK:  ;ddddddddddddddxkOk;  .                  '
 * ;             c000kdddooddodddod0NNNNNNNNNNNNNNNNNNNNNNx. .lddxxddxddddddxkOl. ';                  :
 * d.          .cOK0kdoooddoododddkKNNNNNNNNNNNNNNNNNNNNNNXo. .cdddddddddddxkOo. .d:                 .x
 * 0'         'oO0OkdooddodoodododOXNNNNNNNNNNNNNNNNNNNNNNNXd. .;ldddddddxxxd:. 'x0;                 ,K
 * Wo       .lO00Oxdool:clooddoooxKNNNNNNNNNNNNNNNNNNNNNNNNNXOc. ..;:clllc:,. .cONO'                .dW
 * MK;    .:k00Oxdddoooc,';coddddOXNNNNNNNNNNNNNNNNNNNNNNNNNNNXOo;..      ..;oOXNNx.                :XM
 * MWk.  ,d00Okddodooddol:'.,lodkXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXKOxdoooxkKXNNNNXl                'OMM
 * MMWx,cO0Okdoodddooddoolc,..:xKNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNK:               .xWMM
 * MMMWX00kxdddoddooddddolcc;..lXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN0'              .dWMMM
 * MMMMWXkddddoodddoodddoolcc;..dXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNk.             .xWMMMM
 * MMMMMWKxddddoddoodddooolccc' 'kNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNo.            'kWMMMMM
 * MMMMMMWXkddodddddoddddolccc:. cKNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNK:            ;0WMMMMMM
 * MMMMMMMMN0xddodddodddolccccc' .kNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNk.          .oXMMMMMMMM
 * MMMMMMMMMWXOddoddddddolccccc;. lXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXl          ;OWMMMMMMMMM
 * MMMMMMMMMMMWKkddddoddolccccl;. ;0XNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNk.        'xNMMMMMMMMMMM
 * MMMMMMMMMMMMMNKkddodolcccccc;. ;O0KXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN0:       'dXMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMNKOxollcccccc,  cO000KXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXKl.    .;xXMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMWXOdlcccccc. .d000000KXXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXK0o.   'lONMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMNKkdllc,  cO000000000KXXNNNNNNNNNNNNNNNNNNNNNNNXXKK00o. .ckXWMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMWNKOo'.:k00000000000000KKXXXXXXNNNNNNNXXXXXKK00000kooOXWMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMWK0KXK0000000000000000000000KKKKK000000000KXXNNWMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNXXKK0000000000000000000000KKXXNNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNXXKKKKKKKKKKKKKKXXNNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 *
 * Written by: MrGreenCrypto
 * Co-Founder of CodeCraftrs.com
 * 
 * SPDX-License-Identifier: None
 */

pragma solidity 0.8.17;

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IDEXPair {
    function sync() external;
}

interface IDEXRouter {
    function factory() external pure returns (address);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn, 
        uint256 amountOutMin, 
        address[] calldata path, 
        address to, 
        uint256 deadline
    ) external;
}

contract NewBirb is IBEP20 {
    string public constant name = "Birb";
    string public constant symbol = "BIRB";
    uint8 public constant decimals = 18;
    uint256 constant _totalSupply = 100_000_000 * (10**decimals);

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) public limitless;

    uint256 public buyTax = 0;
    uint256 public sellTax = 5;
    
    uint256 private buyLiq = 0;
    uint256 private buyMarketing = 0;
    uint256 private buyToken = 0;
    uint256 private buyBurn = 0;
    uint256 private sellLiq = 2;
    uint256 private sellMarketing = 3;
    uint256 private sellToken = 0;
    uint256 private sellBurn = 0;
    uint256 private taxDivisor = 100;
    uint256 private swapBirbAt = _totalSupply / 10_000;

    IDEXRouter public constant ROUTER = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    address public constant CEO = 0x6AE2C08E6A91BEc45f6F64E96d8157F6B5DE3536;
    address public constant OWNER = 0x43CC8a482957B617E7536C7d1816e61901B8d481;
    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;
    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
           
    address public marketingWallet = 0x02a05695989120517CC0bA9940741ff5323d7067;
    address public tokenWallet = 0x1C11409562C815B53c943868e6de58b15725AC6c;
    address public immutable pcsPair;
    address[] public pairs;

    modifier onlyOwner(){
        require (msg.sender == OWNER, "Only the OWNER can do that");
        _;
    }

    event WalletsChanged(address marketingWallet, address tokenWallet);
    event SwapBirbAtSet(uint256 swapBirbAt);
    event TokenRescued(address tokenRescued, uint256 amountRescued);
    event BnbRescued(uint256 balanceRescued);
    event ExcludedAddressFromTax(address wallet);
    event UnExcludedAddressFromTax(address wallet);
    event AirdropsSent(address[] airdropWallets, uint256[] amount);
    event MarketingTaxSwapped(uint256 bnbReceived);
    event PairAdded(address addedPair);
    event PairRemoved(address removedPair);
    
    event TaxesChanged(
        uint256 sellTax,
        uint256 buyTax,
        uint256 newBuyLiq,
        uint256 newBuyMarketing,
        uint256 newBuyToken,
        uint256 newBuyBurn,
        uint256 newSellLiq,
        uint256 newSellMarketing,
        uint256 newSellToken,
        uint256 newSellBurn,
        uint256 newTaxDivisor
    );

    constructor() {
        pcsPair = IDEXFactory(IDEXRouter(ROUTER).factory()).createPair(WBNB, address(this));
        pairs.push(pcsPair);
        _allowances[address(this)][address(ROUTER)] = type(uint256).max;

        limitless[CEO] = true;
        limitless[address(this)] = true;

        _balances[CEO] = _totalSupply;
        emit Transfer(address(0), CEO, _totalSupply);
    }

    receive() external payable {}

    function totalSupply() public view override returns (uint256) {return _totalSupply - _balances[DEAD];}
    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}
    function allowance(address holder, address spender) public view override returns (uint256) {return _allowances[holder][spender];}
    function approveMax(address spender) external returns (bool) {return approve(spender, type(uint256).max);}
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        require(spender != address(0), "Can't use zero address here");
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0), "Can't use zero address here");
        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) + addedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        require(spender != address(0), "Can't use zero address here");
        require(allowance(msg.sender, spender) >= subtractedValue, "Can't subtract more than current allowance");
        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) - subtractedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }
    
    function transfer(address recipient, uint256 amount) external override returns (bool) {
        return _transferFrom(msg.sender, recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount ) external override returns (bool) {
        if (_allowances[sender][msg.sender] != type(uint256).max) {
            require(_allowances[sender][msg.sender] >= amount, "Insufficient Allowance");
            _allowances[sender][msg.sender] -= amount;
            emit Approval(sender, msg.sender, _allowances[sender][msg.sender]);
        }
        
        return _transferFrom(sender, recipient, amount);
    }

    function setBirbWallets(address marketingAddress, address tokenAddress) external onlyOwner {
        require(marketingAddress != address(0) && tokenAddress != address(0), "Can't use zero addresses here");
        marketingWallet = marketingAddress;
        tokenWallet = tokenAddress;
        emit WalletsChanged(marketingWallet, tokenWallet);
    }
    
    function setSwapBirbAt(uint256 _swapBirbAt) external onlyOwner{
        require(_swapBirbAt <= _totalSupply / 50, "Can't set the amount to sell to higher than 2% of totalSupply");  
        swapBirbAt = _swapBirbAt;
        emit SwapBirbAtSet(swapBirbAt);
    }

    function rescueAnyToken(address tokenToRescue) external onlyOwner {
        require(tokenToRescue != address(this), "Can't rescue your own");
        emit TokenRescued(tokenToRescue, IBEP20(tokenToRescue).balanceOf(address(this)));
        IBEP20(tokenToRescue).transfer(CEO, IBEP20(tokenToRescue).balanceOf(address(this)));
    }

    function rescueBnb() external onlyOwner {
        emit BnbRescued(address(this).balance);
        (bool success, ) = CEO.call{value: address(this).balance}("");
        require(success, "Something went wrong");
    }

    function setSellTax(uint256 newTaxDivisor, uint256 newSellLiq, uint256 newSellMarketing, uint256 newSellToken, uint256 newSellBurn) external onlyOwner {
        taxDivisor     = newTaxDivisor;
        sellLiq        = newSellLiq;
        sellMarketing  = newSellMarketing;
        sellToken      = newSellToken;
        sellBurn       = newSellBurn;
        sellTax        = sellLiq + sellMarketing + sellToken + sellBurn;
        require(buyTax <= taxDivisor / 20 || sellTax <= taxDivisor / 20, "Taxes are limited to max. 5%");
        
        emit TaxesChanged(
            sellTax,
            buyTax,
            buyLiq,
            buyMarketing,
            buyToken,
            buyBurn,
            newSellLiq,
            newSellMarketing,
            newSellToken,
            newSellBurn,
            newTaxDivisor
        );
    }

    function setBuyTax(uint256 newTaxDivisor, uint256 newBuyLiq, uint256 newBuyMarketing, uint256 newBuyToken, uint256 newBuyBurn) external onlyOwner {
        taxDivisor     = newTaxDivisor;
        buyLiq         = newBuyLiq;
        buyMarketing   = newBuyMarketing;
        buyToken       = newBuyToken;
        buyBurn        = newBuyBurn;
        buyTax         = buyLiq + buyMarketing + buyToken + buyBurn;
        require(buyTax <= taxDivisor / 20 || sellTax <= taxDivisor / 20, "Taxes are limited to max. 5%");
        
        emit TaxesChanged(
            sellTax,
            buyTax,
            newBuyLiq,
            newBuyMarketing,
            newBuyToken,
            newBuyBurn,
            sellLiq,
            sellMarketing,
            sellToken,
            sellBurn,
            newTaxDivisor
        );
    }

    function setAddressTaxStatus(address wallet, bool status) external onlyOwner {
        limitless[wallet] = status;
        if(status) emit ExcludedAddressFromTax(wallet);
        else emit UnExcludedAddressFromTax(wallet);
    }

    function isContract(address account) internal view returns (bool) {
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

    function addPair(address pairToAdd) external onlyOwner {
        require(isContract(pairToAdd) && pairToAdd != address(this) && pairToAdd != address(ROUTER), "This address can not be set as a pair");
        pairs.push(pairToAdd);
        emit PairAdded(pairToAdd);
    }

    function removeLastPair() external onlyOwner {
        address pairToBeRemoved = pairs[pairs.length-1];
        if(pairs.length == 1) return;
        pairs.pop();
        emit PairRemoved(pairToBeRemoved);
    }

    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if (limitless[sender] || limitless[recipient]) return _lowGasTransfer(sender, recipient, amount);
        amount = takeTax(sender, recipient, amount);
        return _lowGasTransfer(sender, recipient, amount);
    }

    function takeTax(address sender, address recipient, uint256 amount) internal returns (uint256) {
        uint256 taxAmount = 0;
        uint256 totalTax = 0;
        
        if(isPair(sender)) {
            totalTax = buyTax;
            if(totalTax == 0) return amount;
            taxAmount = amount * totalTax / taxDivisor;
            
            if(buyBurn > 0) 
                _lowGasTransfer(sender, DEAD, taxAmount * buyBurn / totalTax);
            
            if(buyToken > 0) 
                _lowGasTransfer(sender, tokenWallet, taxAmount * buyToken / totalTax);
            
            if(buyLiq > 0) 
                _lowGasTransfer(sender, pcsPair, taxAmount * buyLiq / totalTax);
            
            if(buyMarketing > 0) 
                _lowGasTransfer(sender, address(this), taxAmount * buyMarketing / totalTax);
            
            return amount - taxAmount;
        }

        if(isPair(recipient)) {
            totalTax = sellTax;
            if(totalTax == 0) return amount;
            taxAmount = amount * sellTax / taxDivisor;
            
            if(sellBurn > 0) 
                _lowGasTransfer(sender, DEAD, taxAmount * sellBurn / totalTax);
            
            if(sellToken > 0) 
                _lowGasTransfer(sender, tokenWallet, taxAmount * sellToken / totalTax);
            
            if(sellLiq > 0) 
                _lowGasTransfer(sender, pcsPair, taxAmount * sellLiq / totalTax);
            
            if(sellMarketing > 0) 
                _lowGasTransfer(sender, address(this), taxAmount * sellMarketing / totalTax);
            
            if(balanceOf(address(this)) >= swapBirbAt) {
                swapBirb();
            } else if(sellLiq > 0) {
                IDEXPair(pcsPair).sync();
            }
        }

        return amount - taxAmount;
    }

    function isPair(address check) internal view returns(bool) {
        for (uint256 i = 0; i < pairs.length; i++) if(check == pairs[i]) return true;
        return false;
    }

    function _lowGasTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {
        require(sender != address(0) && recipient != address(0), "Can't use zero addresses here");
        require(amount <= _balances[sender], "Can't transfer more than you own");
        if(amount == 0) return true;
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function swapBirb() internal {
        uint256 contractBalance = _balances[address(this)];
        if(contractBalance == 0) return;
        uint256 balanceBefore = marketingWallet.balance;
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

        ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(
            contractBalance,
            0,
            path,
            marketingWallet,
            block.timestamp
        );

        emit MarketingTaxSwapped(marketingWallet.balance - balanceBefore);
    }
}
